import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Play, Pause, Brain, Eye, Zap, Target, Users, Lightbulb } from 'lucide-react';

// --- Enhanced Configuration ---
const LATENT_DIM = 64;
const MAIN_SCOUTS = 100;      // Large scouts that form main thought clusters
const DETAIL_SCOUTS = 1500;   // Small scouts that investigate details
const CLUSTER_THRESHOLD = 8;  // Distance for scouts to be considered in same cluster
const CLUSTER_MIN_SIZE = 5;   // Minimum scouts needed to form a main cluster
const ATTENTION_DECAY = 0.95; // How quickly attention fades

// --- Enhanced VAE with better feature detection ---
const useEnhancedVAE = (width, height) => {
    const vaeState = useRef({
        encoderWeights: Array.from({ length: 9 }, () => Math.random()),
        decoderWeights: Array.from({ length: 9 }, () => Math.random()),
        latentSpace: new Float32Array(LATENT_DIM * LATENT_DIM),
        featureMap: new Float32Array(LATENT_DIM * LATENT_DIM), // Enhanced feature detection
    });

    const detectFeatures = useCallback((imageData) => {
        const { data } = imageData;
        const features = vaeState.current.featureMap;
        
        // Enhanced feature detection with edge, texture, and color analysis
        for (let y = 1; y < LATENT_DIM - 1; y++) {
            for (let x = 1; x < LATENT_DIM - 1; x++) {
                const sourceX = Math.floor(x * (width / LATENT_DIM));
                const sourceY = Math.floor(y * (height / LATENT_DIM));
                
                // Sample 3x3 region for feature detection
                let edgeStrength = 0;
                let colorVariance = 0;
                let brightness = 0;
                
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const pixelIdx = ((sourceY + dy) * width + (sourceX + dx)) * 4;
                        const r = data[pixelIdx] || 0;
                        const g = data[pixelIdx + 1] || 0;
                        const b = data[pixelIdx + 2] || 0;
                        
                        brightness += (r + g + b) / 3;
                        
                        // Simple edge detection
                        if (dx === 0 && dy === 0) {
                            const centerBrightness = (r + g + b) / 3;
                            edgeStrength += Math.abs(centerBrightness - brightness / 9);
                        }
                        
                        // Color variance
                        colorVariance += Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r);
                    }
                }
                
                brightness /= 9;
                
                // Combine features into a single activation value
                const featureValue = Math.tanh(
                    (edgeStrength / 100) + 
                    (colorVariance / 500) + 
                    (brightness / 255) - 0.5
                );
                
                features[y * LATENT_DIM + x] = featureValue;
            }
        }
        
        return features;
    }, [width, height]);

    const simulateEncoder = useCallback((imageData) => {
        const features = detectFeatures(imageData);
        vaeState.current.latentSpace.set(features);
        return features;
    }, [detectFeatures]);

    const simulateDecoder = useCallback((latent) => {
        const decodedData = new Uint8ClampedArray(width * height * 4);
        const weights = vaeState.current.decoderWeights;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const latentX = Math.floor(x * (LATENT_DIM / width));
                const latentY = Math.floor(y * (LATENT_DIM / height));
                const latentValue = latent[latentY * LATENT_DIM + latentX];

                const pixelIdx = (y * width + x) * 4;
                
                // Enhanced decoding with color mixing
                const r = Math.max(0, Math.min(255, (latentValue * weights[0] + 0.5) * 255));
                const g = Math.max(0, Math.min(255, (latentValue * weights[1] + 0.5) * 255));
                const b = Math.max(0, Math.min(255, (latentValue * weights[2] + 0.5) * 255));
                
                decodedData[pixelIdx] = r;
                decodedData[pixelIdx + 1] = g;
                decodedData[pixelIdx + 2] = b;
                decodedData[pixelIdx + 3] = 255;
            }
        }
        return new ImageData(decodedData, width, height);
    }, [width, height]);

    return { vaeState, simulateEncoder, simulateDecoder };
};

// --- Hierarchical Scout System ---
const useHierarchicalScouts = () => {
    const mainScoutsRef = useRef([]);
    const detailScoutsRef = useRef([]);
    const clustersRef = useRef([]);
    const attentionRef = useRef({ x: LATENT_DIM/2, y: LATENT_DIM/2, strength: 0 });

    const initializeScouts = useCallback(() => {
        // Initialize main scouts (larger, form primary clusters)
        mainScoutsRef.current = Array.from({ length: MAIN_SCOUTS }, () => ({
            x: Math.random() * LATENT_DIM,
            y: Math.random() * LATENT_DIM,
            vx: 0,
            vy: 0,
            activation: 0,
            clusterId: -1,
            type: 'main'
        }));

        // Initialize detail scouts (smaller, investigate details)
        detailScoutsRef.current = Array.from({ length: DETAIL_SCOUTS }, () => ({
            x: Math.random() * LATENT_DIM,
            y: Math.random() * LATENT_DIM,
            vx: 0,
            vy: 0,
            activation: 0,
            targetCluster: -1,
            type: 'detail'
        }));
    }, []);

    const findClusters = useCallback(() => {
        const clusters = [];
        const visited = new Set();
        
        mainScoutsRef.current.forEach((scout, i) => {
            if (visited.has(i)) return;
            
            const cluster = { scouts: [], centerX: 0, centerY: 0, activation: 0, concept: 'unknown' };
            const queue = [i];
            
            while (queue.length > 0) {
                const currentIdx = queue.pop();
                if (visited.has(currentIdx)) continue;
                
                visited.add(currentIdx);
                const currentScout = mainScoutsRef.current[currentIdx];
                cluster.scouts.push(currentIdx);
                
                // Find nearby scouts
                mainScoutsRef.current.forEach((otherScout, j) => {
                    if (visited.has(j)) return;
                    
                    const dx = currentScout.x - otherScout.x;
                    const dy = currentScout.y - otherScout.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < CLUSTER_THRESHOLD) {
                        queue.push(j);
                    }
                });
            }
            
            if (cluster.scouts.length >= CLUSTER_MIN_SIZE) {
                // Calculate cluster center and activation
                cluster.scouts.forEach(idx => {
                    const scout = mainScoutsRef.current[idx];
                    cluster.centerX += scout.x;
                    cluster.centerY += scout.y;
                    cluster.activation += scout.activation;
                    scout.clusterId = clusters.length;
                });
                
                cluster.centerX /= cluster.scouts.length;
                cluster.centerY /= cluster.scouts.length;
                cluster.activation /= cluster.scouts.length;
                
                // Simple concept detection based on position and activation
                if (cluster.activation > 0.7) {
                    cluster.concept = 'high_interest';
                } else if (cluster.centerX < LATENT_DIM * 0.3) {
                    cluster.concept = 'left_feature';
                } else if (cluster.centerX > LATENT_DIM * 0.7) {
                    cluster.concept = 'right_feature';
                } else if (cluster.centerY < LATENT_DIM * 0.3) {
                    cluster.concept = 'top_feature';
                } else if (cluster.centerY > LATENT_DIM * 0.7) {
                    cluster.concept = 'bottom_feature';
                } else {
                    cluster.concept = 'central_feature';
                }
                
                clusters.push(cluster);
            }
        });
        
        clustersRef.current = clusters;
        return clusters;
    }, []);

    const updateScouts = useCallback((latentSpace) => {
        // Update main scouts
        mainScoutsRef.current.forEach(scout => {
            const ix = Math.floor(scout.x);
            const iy = Math.floor(scout.y);
            
            if (ix > 0 && ix < LATENT_DIM - 1 && iy > 0 && iy < LATENT_DIM - 1) {
                const idx = iy * LATENT_DIM + ix;
                const activation = latentSpace[idx];
                
                // Update scout activation
                scout.activation = scout.activation * 0.9 + activation * 0.1;
                
                // Calculate forces
                const gradX = (latentSpace[idx + 1] - latentSpace[idx - 1]) / 2;
                const gradY = (latentSpace[idx + LATENT_DIM] - latentSpace[idx - LATENT_DIM]) / 2;
                
                // Main scouts are attracted to strong features
                const forceX = gradX * Math.abs(activation) * 2;
                const forceY = gradY * Math.abs(activation) * 2;
                
                scout.vx = scout.vx * 0.8 + forceX * 0.5 + (Math.random() - 0.5) * 0.3;
                scout.vy = scout.vy * 0.8 + forceY * 0.5 + (Math.random() - 0.5) * 0.3;
            }
            
            scout.x += scout.vx;
            scout.y += scout.vy;
            
            // Boundaries
            scout.x = Math.max(1, Math.min(LATENT_DIM - 2, scout.x));
            scout.y = Math.max(1, Math.min(LATENT_DIM - 2, scout.y));
        });
        
        // Find clusters
        const clusters = findClusters();
        
        // Update global attention based on strongest cluster
        if (clusters.length > 0) {
            const strongestCluster = clusters.reduce((max, cluster) => 
                cluster.activation > max.activation ? cluster : max
            );
            
            attentionRef.current.x = strongestCluster.centerX;
            attentionRef.current.y = strongestCluster.centerY;
            attentionRef.current.strength = strongestCluster.activation;
        }
        
        // Update detail scouts
        detailScoutsRef.current.forEach(scout => {
            const ix = Math.floor(scout.x);
            const iy = Math.floor(scout.y);
            
            if (ix > 0 && ix < LATENT_DIM - 1 && iy > 0 && iy < LATENT_DIM - 1) {
                const idx = iy * LATENT_DIM + ix;
                const activation = latentSpace[idx];
                
                scout.activation = scout.activation * 0.95 + activation * 0.05;
                
                // Detail scouts are attracted to attention center and nearby details
                const dx = attentionRef.current.x - scout.x;
                const dy = attentionRef.current.y - scout.y;
                const distToAttention = Math.sqrt(dx * dx + dy * dy);
                
                let forceX = 0;
                let forceY = 0;
                
                if (distToAttention < 20) {
                    // Close to attention - explore local details
                    const gradX = (latentSpace[idx + 1] - latentSpace[idx - 1]) / 2;
                    const gradY = (latentSpace[idx + LATENT_DIM] - latentSpace[idx - LATENT_DIM]) / 2;
                    forceX = gradX * 0.3;
                    forceY = gradY * 0.3;
                } else {
                    // Far from attention - move toward it
                    forceX = dx * 0.1 / distToAttention;
                    forceY = dy * 0.1 / distToAttention;
                }
                
                scout.vx = scout.vx * 0.9 + forceX + (Math.random() - 0.5) * 0.2;
                scout.vy = scout.vy * 0.9 + forceY + (Math.random() - 0.5) * 0.2;
            }
            
            scout.x += scout.vx;
            scout.y += scout.vy;
            
            // Boundaries
            scout.x = Math.max(1, Math.min(LATENT_DIM - 2, scout.x));
            scout.y = Math.max(1, Math.min(LATENT_DIM - 2, scout.y));
        });
    }, [findClusters]);

    return { 
        mainScoutsRef, 
        detailScoutsRef, 
        clustersRef, 
        attentionRef,
        initializeScouts, 
        updateScouts 
    };
};

// --- Main Component ---
const HierarchicalThoughtSystem = () => {
    const [isRunning, setIsRunning] = useState(false);
    const [clusterCount, setClusterCount] = useState(0);
    const [dominantConcept, setDominantConcept] = useState('none');
    const [attentionStrength, setAttentionStrength] = useState(0);

    const videoRef = useRef(null);
    const inputCanvasRef = useRef(null);
    const vaeCanvasRef = useRef(null);
    const mindCanvasRef = useRef(null);
    const animationFrameId = useRef();
    
    const width = 320;
    const height = 240;

    const { vaeState, simulateEncoder, simulateDecoder } = useEnhancedVAE(width, height);
    const { 
        mainScoutsRef, 
        detailScoutsRef, 
        clustersRef, 
        attentionRef,
        initializeScouts, 
        updateScouts 
    } = useHierarchicalScouts();

    useEffect(() => {
        initializeScouts();
    }, [initializeScouts]);

    const setupWebcam = async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width, height } });
            if (videoRef.current) {
                videoRef.current.srcObject = stream;
            }
        } catch (err) {
            console.error("Error accessing webcam:", err);
        }
    };
    
    useEffect(() => {
        setupWebcam();
    }, []);

    const animate = useCallback(() => {
        if (!isRunning) return;

        // Process webcam input
        const inputCtx = inputCanvasRef.current.getContext('2d');
        inputCtx.drawImage(videoRef.current, 0, 0, width, height);
        const imageData = inputCtx.getImageData(0, 0, width, height);

        // VAE processing
        const latentSpace = simulateEncoder(imageData);
        const reconstructedImage = simulateDecoder(latentSpace);
        const vaeCtx = vaeCanvasRef.current.getContext('2d');
        vaeCtx.putImageData(reconstructedImage, 0, 0);

        // Update scouts
        updateScouts(latentSpace);

        // Update UI metrics
        setClusterCount(clustersRef.current.length);
        setAttentionStrength(attentionRef.current.strength);
        
        if (clustersRef.current.length > 0) {
            const strongest = clustersRef.current.reduce((max, cluster) => 
                cluster.activation > max.activation ? cluster : max
            );
            setDominantConcept(strongest.concept);
        }

        // Render mind visualization
        const mindCtx = mindCanvasRef.current.getContext('2d');
        mindCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        mindCtx.fillRect(0, 0, LATENT_DIM * 6, LATENT_DIM * 6);

        // Draw latent space background
        const mindImageData = mindCtx.createImageData(LATENT_DIM, LATENT_DIM);
        for(let i = 0; i < latentSpace.length; i++) {
            const v = Math.max(0, Math.min(255, (latentSpace[i] + 1) * 127));
            mindImageData.data[i*4] = v/3;
            mindImageData.data[i*4+1] = v/2;
            mindImageData.data[i*4+2] = v;
            mindImageData.data[i*4+3] = 255;
        }
        
        createImageBitmap(mindImageData).then(bmp => {
            mindCtx.drawImage(bmp, 0, 0, LATENT_DIM * 6, LATENT_DIM * 6);
            
            // Draw attention center
            mindCtx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
            mindCtx.lineWidth = 3;
            mindCtx.beginPath();
            mindCtx.arc(
                attentionRef.current.x * 6, 
                attentionRef.current.y * 6, 
                20 * attentionRef.current.strength, 
                0, 2 * Math.PI
            );
            mindCtx.stroke();
            
            // Draw clusters
            clustersRef.current.forEach((cluster, i) => {
                mindCtx.strokeStyle = `hsl(${i * 60}, 70%, 60%)`;
                mindCtx.lineWidth = 2;
                mindCtx.beginPath();
                mindCtx.arc(cluster.centerX * 6, cluster.centerY * 6, 15, 0, 2 * Math.PI);
                mindCtx.stroke();
                
                // Cluster label
                mindCtx.fillStyle = 'white';
                mindCtx.font = '10px Arial';
                mindCtx.fillText(
                    cluster.concept, 
                    cluster.centerX * 6 + 20, 
                    cluster.centerY * 6
                );
            });
            
            // Draw main scouts
            mindCtx.fillStyle = 'rgba(255, 100, 100, 0.8)';
            mainScoutsRef.current.forEach(scout => {
                mindCtx.beginPath();
                mindCtx.arc(scout.x * 6, scout.y * 6, 2, 0, 2 * Math.PI);
                mindCtx.fill();
            });
            
            // Draw detail scouts
            mindCtx.fillStyle = 'rgba(100, 255, 100, 0.6)';
            detailScoutsRef.current.forEach(scout => {
                mindCtx.beginPath();
                mindCtx.arc(scout.x * 6, scout.y * 6, 1, 0, 2 * Math.PI);
                mindCtx.fill();
            });
        });

        animationFrameId.current = requestAnimationFrame(animate);
    }, [isRunning, simulateEncoder, simulateDecoder, updateScouts]);

    useEffect(() => {
        if (isRunning) {
            animationFrameId.current = requestAnimationFrame(animate);
        } else {
            cancelAnimationFrame(animationFrameId.current);
        }
        return () => cancelAnimationFrame(animationFrameId.current);
    }, [isRunning, animate]);

    return (
        <div className="min-h-screen bg-gray-900 text-white p-4">
            <div className="max-w-7xl mx-auto">
                <header className="text-center mb-4">
                    <h1 className="text-4xl font-bold text-cyan-400 flex items-center justify-center gap-3">
                        <Brain size={36} /> Hierarchical Thought System
                    </h1>
                    <p className="text-gray-400">Main thoughts cluster, detail scouts investigate</p>
                </header>

                <div className="flex justify-center items-center gap-6 mb-4 p-4 bg-gray-800 rounded-lg">
                    <button
                        onClick={() => setIsRunning(!isRunning)}
                        className={`px-6 py-2 rounded-lg font-semibold flex items-center gap-2 ${
                            isRunning ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600'
                        }`}
                    >
                        {isRunning ? <Pause /> : <Play />}
                        {isRunning ? 'Pause' : 'Start'}
                    </button>
                    
                    <div className="flex items-center gap-4 text-sm">
                        <div className="flex items-center gap-2">
                            <Target className="w-4 h-4 text-yellow-400" />
                            <span>Clusters: {clusterCount}</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <Lightbulb className="w-4 h-4 text-orange-400" />
                            <span>Focus: {dominantConcept}</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <Zap className="w-4 h-4 text-cyan-400" />
                            <span>Attention: {(attentionStrength * 100).toFixed(0)}%</span>
                        </div>
                    </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div className="p-4 bg-gray-800 rounded-lg">
                        <h2 className="text-lg font-semibold mb-2 flex items-center gap-2">
                            <Eye /> Live Input
                        </h2>
                        <canvas ref={inputCanvasRef} width={width} height={height} className="w-full h-auto rounded bg-black" />
                    </div>
                    
                    <div className="p-4 bg-gray-800 rounded-lg">
                        <h2 className="text-lg font-semibold mb-2 flex items-center gap-2">
                            <Zap /> VAE Reconstruction
                        </h2>
                        <canvas ref={vaeCanvasRef} width={width} height={height} className="w-full h-auto rounded bg-black" />
                    </div>
                    
                    <div className="p-4 bg-gray-800 rounded-lg">
                        <h2 className="text-lg font-semibold mb-2 flex items-center gap-2">
                            <Brain /> Hierarchical Mind
                        </h2>
                        <canvas ref={mindCanvasRef} width={LATENT_DIM * 6} height={LATENT_DIM * 6} className="w-full h-auto rounded bg-black" />
                        <div className="mt-2 text-xs text-gray-400">
                            <div className="flex items-center gap-4">
                                <div className="flex items-center gap-1">
                                    <div className="w-3 h-3 bg-red-400 rounded-full"></div>
                                    <span>Main Scouts</span>
                                </div>
                                <div className="flex items-center gap-1">
                                    <div className="w-3 h-3 bg-green-400 rounded-full"></div>
                                    <span>Detail Scouts</span>
                                </div>
                                <div className="flex items-center gap-1">
                                    <div className="w-3 h-3 border-2 border-yellow-400 rounded-full"></div>
                                    <span>Attention</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div className="mt-4 p-4 bg-gray-800 rounded-lg">
                    <h3 className="text-lg font-semibold mb-2">What You're Seeing</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-gray-300">
                        <div>
                            <h4 className="font-semibold text-white mb-1">Main Scouts (Red)</h4>
                            <p>Large scouts that cluster around major features. When they group together, they form "concept clusters" with labels.</p>
                        </div>
                        <div>
                            <h4 className="font-semibold text-white mb-1">Detail Scouts (Green)</h4>
                            <p>Small scouts that investigate details. They're attracted to the main attention center and explore local features.</p>
                        </div>
                        <div>
                            <h4 className="font-semibold text-white mb-1">Attention Center (Yellow Circle)</h4>
                            <p>The global focus of the system. Size shows attention strength. This is where the system is "thinking" about.</p>
                        </div>
                        <div>
                            <h4 className="font-semibold text-white mb-1">Concept Clusters (Colored Circles)</h4>
                            <p>When main scouts group together, they form concept clusters. Each gets a label based on its properties.</p>
                        </div>
                    </div>
                </div>

                <video ref={videoRef} autoPlay playsInline className="hidden" />
            </div>
        </div>
    );
};

export default HierarchicalThoughtSystem;