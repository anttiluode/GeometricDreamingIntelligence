import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Brain, Play, Pause, RotateCcw, Download, Video } from 'lucide-react';

const FIELD_SIZE = 256;
const MAX_SCOUTS = 3000;

// Temporal Field System - The Core Intelligence
class TemporalField {
    constructor() {
        this.width = FIELD_SIZE;
        this.height = FIELD_SIZE;
        this.current = new Float32Array(FIELD_SIZE * FIELD_SIZE);
        this.history = [];
        this.maxHistory = 30;
        this.emergenceField = new Float32Array(FIELD_SIZE * FIELD_SIZE);
        this.concepts = new Map();
        this.scouts = [];
        this.nextConceptId = 0;
        this.initializeScouts();
    }
    
    initializeScouts() {
        this.scouts = [];
        for (let i = 0; i < MAX_SCOUTS; i++) {
            this.scouts.push({
                x: Math.random() * this.width,
                y: Math.random() * this.height,
                vx: 0,
                vy: 0,
                energy: 0,
                type: Math.floor(Math.random() * 4), // 0=edge, 1=motion, 2=persistence, 3=emergence
                age: 0,
                conceptBinding: null,
                temporalSignature: new Float32Array(16)
            });
        }
    }
    
    updateFromImage(imageData) {
        // Convert to luminance
        for (let i = 0; i < this.current.length; i++) {
            const r = imageData.data[i * 4] / 255;
            const g = imageData.data[i * 4 + 1] / 255;
            const b = imageData.data[i * 4 + 2] / 255;
            this.current[i] = 0.299 * r + 0.587 * g + 0.114 * b;
        }
        
        this.history.push(new Float32Array(this.current));
        if (this.history.length > this.maxHistory) {
            this.history.shift();
        }
        
        this.computeEmergenceField();
        this.evolveScouts();
        this.detectConcepts();
    }
    
    computeEmergenceField() {
        if (this.history.length < 3) return;
        
        const emergenceRate = 0.02;
        
        for (let i = 0; i < this.emergenceField.length; i++) {
            let temporalVariance = 0;
            let spatialGradient = 0;
            let persistence = 0;
            
            if (this.history.length >= 2) {
                const recent = this.history[this.history.length - 1][i];
                const past = this.history[this.history.length - 2][i];
                temporalVariance = Math.abs(recent - past);
            }
            
            const x = i % this.width;
            const y = Math.floor(i / this.width);
            if (x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1) {
                const gx = this.current[i + 1] - this.current[i - 1];
                const gy = this.current[i + this.width] - this.current[i - this.width];
                spatialGradient = Math.sqrt(gx * gx + gy * gy);
            }
            
            if (this.history.length >= 5) {
                let stability = 0;
                for (let h = 1; h < Math.min(5, this.history.length); h++) {
                    stability += Math.abs(this.current[i] - this.history[this.history.length - 1 - h][i]);
                }
                persistence = 1.0 / (1.0 + stability * 10);
            }
            
            this.emergenceField[i] = this.emergenceField[i] * (1 - emergenceRate) + 
                (temporalVariance * 0.4 + spatialGradient * 0.3 + persistence * 0.3) * emergenceRate;
        }
    }
    
    evolveScouts() {
        this.scouts.forEach(scout => {
            scout.age++;
            
            const x = Math.floor(scout.x);
            const y = Math.floor(scout.y);
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
            
            const idx = y * this.width + x;
            const emergence = this.emergenceField[idx];
            
            // Update temporal signature
            for (let i = 0; i < scout.temporalSignature.length - 1; i++) {
                scout.temporalSignature[i] = scout.temporalSignature[i + 1];
            }
            scout.temporalSignature[scout.temporalSignature.length - 1] = emergence;
            
            let fx = 0, fy = 0;
            
            switch (scout.type) {
                case 0: // Edge detector
                    if (x > 0 && x < this.width - 1) {
                        const gx = this.current[idx + 1] - this.current[idx - 1];
                        fx = gx * 10;
                    }
                    if (y > 0 && y < this.height - 1) {
                        const gy = this.current[idx + this.width] - this.current[idx - this.width];
                        fy = gy * 10;
                    }
                    break;
                    
                case 1: // Motion detector
                    if (this.history.length >= 2) {
                        const motion = this.current[idx] - this.history[this.history.length - 2][idx];
                        fx = Math.random() - 0.5 + motion * 20;
                        fy = Math.random() - 0.5 + motion * 20;
                    }
                    break;
                    
                case 2: // Persistence tracker
                    fx = (emergence - 0.5) * 5;
                    fy = (emergence - 0.5) * 5;
                    break;
                    
                case 3: // Emergence seeker
                    if (x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1) {
                        const egx = this.emergenceField[idx + 1] - this.emergenceField[idx - 1];
                        const egy = this.emergenceField[idx + this.width] - this.emergenceField[idx - this.width];
                        fx = egx * 15;
                        fy = egy * 15;
                    }
                    break;
            }
            
            fx += (Math.random() - 0.5) * 2;
            fy += (Math.random() - 0.5) * 2;
            
            scout.vx = scout.vx * 0.8 + fx * 0.1;
            scout.vy = scout.vy * 0.8 + fy * 0.1;
            
            scout.x += scout.vx;
            scout.y += scout.vy;
            
            scout.x = Math.max(5, Math.min(this.width - 5, scout.x));
            scout.y = Math.max(5, Math.min(this.height - 5, scout.y));
            
            scout.energy = scout.energy * 0.95 + emergence * 0.05;
        });
    }
    
    detectConcepts() {
        const threshold = 0.5;
        const temporalWindow = 30;
        
        const clusters = this.findScoutClusters();
        
        clusters.forEach(cluster => {
            if (cluster.coherence > threshold && cluster.scouts.length > 10) {
                const conceptKey = this.generateConceptKey(cluster);
                
                if (!this.concepts.has(conceptKey)) {
                    const concept = {
                        id: this.nextConceptId++,
                        centerX: cluster.centerX,
                        centerY: cluster.centerY,
                        scouts: cluster.scouts,
                        coherence: cluster.coherence,
                        age: 0,
                        signature: cluster.temporalSignature,
                        name: this.generateConceptName(cluster),
                        stability: 0
                    };
                    
                    this.concepts.set(conceptKey, concept);
                    
                    cluster.scouts.forEach(scout => {
                        scout.conceptBinding = concept.id;
                    });
                } else {
                    const concept = this.concepts.get(conceptKey);
                    concept.age++;
                    concept.stability = Math.min(1.0, concept.stability + 0.01);
                    concept.centerX = (concept.centerX + cluster.centerX) / 2;
                    concept.centerY = (concept.centerY + cluster.centerY) / 2;
                }
            }
        });
        
        for (let [key, concept] of this.concepts) {
            concept.age++;
            if (concept.age > temporalWindow && concept.stability < 0.3) {
                this.concepts.delete(key);
                this.scouts.forEach(scout => {
                    if (scout.conceptBinding === concept.id) {
                        scout.conceptBinding = null;
                    }
                });
            }
        }
    }
    
    findScoutClusters() {
        const clusters = [];
        const visited = new Set();
        
        this.scouts.forEach((scout, i) => {
            if (visited.has(i) || scout.energy < 0.1) return;
            
            const cluster = {
                scouts: [scout],
                centerX: scout.x,
                centerY: scout.y,
                coherence: 0,
                temporalSignature: new Float32Array(16)
            };
            
            visited.add(i);
            
            this.scouts.forEach((otherScout, j) => {
                if (visited.has(j) || i === j) return;
                
                const dx = scout.x - otherScout.x;
                const dy = scout.y - otherScout.y;
                const spatialDist = Math.sqrt(dx * dx + dy * dy);
                
                if (spatialDist < 20) {
                    const correlation = this.calculateTemporalCorrelation(
                        scout.temporalSignature, 
                        otherScout.temporalSignature
                    );
                    
                    if (correlation > 0.6) {
                        cluster.scouts.push(otherScout);
                        visited.add(j);
                    }
                }
            });
            
            if (cluster.scouts.length > 5) {
                cluster.centerX = cluster.scouts.reduce((sum, s) => sum + s.x, 0) / cluster.scouts.length;
                cluster.centerY = cluster.scouts.reduce((sum, s) => sum + s.y, 0) / cluster.scouts.length;
                
                for (let i = 0; i < cluster.temporalSignature.length; i++) {
                    cluster.temporalSignature[i] = cluster.scouts.reduce((sum, s) => sum + s.temporalSignature[i], 0) / cluster.scouts.length;
                }
                
                cluster.coherence = this.calculateClusterCoherence(cluster);
                clusters.push(cluster);
            }
        });
        
        return clusters;
    }
    
    calculateTemporalCorrelation(sig1, sig2) {
        let correlation = 0;
        for (let i = 0; i < sig1.length; i++) {
            correlation += Math.abs(sig1[i] - sig2[i]);
        }
        return 1.0 / (1.0 + correlation);
    }
    
    calculateClusterCoherence(cluster) {
        if (cluster.scouts.length < 2) return 0;
        
        let avgEnergy = cluster.scouts.reduce((sum, s) => sum + s.energy, 0) / cluster.scouts.length;
        let spatialSpread = 0;
        
        cluster.scouts.forEach(scout => {
            const dx = scout.x - cluster.centerX;
            const dy = scout.y - cluster.centerY;
            spatialSpread += Math.sqrt(dx * dx + dy * dy);
        });
        spatialSpread /= cluster.scouts.length;
        
        return avgEnergy / (1.0 + spatialSpread * 0.1);
    }
    
    generateConceptKey(cluster) {
        const x = Math.floor(cluster.centerX / 10);
        const y = Math.floor(cluster.centerY / 10);
        const signature = Array.from(cluster.temporalSignature)
            .map(v => Math.floor(v * 10))
            .join('');
        return `${x}_${y}_${signature.substring(0, 8)}`;
    }
    
    generateConceptName(cluster) {
        const names = [
            'edge_cluster', 'motion_pattern', 'persistent_feature', 
            'temporal_structure', 'emergence_focus', 'attention_node',
            'pattern_junction', 'feature_nexus', 'coherent_signal'
        ];
        return names[Math.floor(Math.random() * names.length)] + '_' + Math.floor(Math.random() * 1000);
    }
}

const TemporalSemanticEmergence = () => {
    const [isRunning, setIsRunning] = useState(false);
    const [stats, setStats] = useState({
        concepts: 0,
        activeScouts: 0,
        semanticDepth: 0
    });
    
    const videoRef = useRef(null);
    const inputCanvasRef = useRef(null);
    const temporalCanvasRef = useRef(null);
    const semanticCanvasRef = useRef(null);
    const animationRef = useRef(null);
    const temporalFieldRef = useRef(new TemporalField());
    
    const startCamera = useCallback(async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: FIELD_SIZE, height: FIELD_SIZE }
            });
            if (videoRef.current) {
                videoRef.current.srcObject = stream;
                await videoRef.current.play();
                setIsRunning(true);
            }
        } catch (err) {
            console.error('Camera access failed:', err);
        }
    }, []);
    
    const renderInput = useCallback((ctx, imageData) => {
        ctx.putImageData(imageData, 0, 0);
    }, []);
    
    const renderTemporalField = useCallback((ctx) => {
        const temporalField = temporalFieldRef.current;
        const imageData = ctx.createImageData(FIELD_SIZE, FIELD_SIZE);
        
        // Render emergence field
        for (let i = 0; i < temporalField.emergenceField.length; i++) {
            const emergence = temporalField.emergenceField[i];
            const intensity = Math.floor(emergence * 255);
            
            imageData.data[i * 4] = intensity;
            imageData.data[i * 4 + 1] = intensity * 0.5;
            imageData.data[i * 4 + 2] = intensity * 0.8;
            imageData.data[i * 4 + 3] = 255;
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Render scouts
        temporalField.scouts.forEach(scout => {
            const colors = ['#ff8800', '#00ffff', '#ffffff', '#ff00ff'];
            ctx.fillStyle = colors[scout.type];
            ctx.globalAlpha = Math.min(1.0, scout.energy * 2);
            ctx.fillRect(scout.x - 1, scout.y - 1, 2, 2);
        });
        
        ctx.globalAlpha = 1.0;
    }, []);
    
    const renderSemanticSpace = useCallback((ctx) => {
        const temporalField = temporalFieldRef.current;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, FIELD_SIZE, FIELD_SIZE);
        
        const concepts = Array.from(temporalField.concepts.values());
        
        concepts.forEach(concept => {
            const alpha = Math.min(1.0, concept.stability);
            ctx.globalAlpha = alpha;
            
            const hue = (concept.id * 137.5) % 360;
            ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
            
            const size = 5 + concept.coherence * 15;
            ctx.beginPath();
            ctx.arc(concept.centerX, concept.centerY, size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.font = '10px monospace';
            ctx.fillText(concept.name, concept.centerX + size + 2, concept.centerY);
        });
        
        ctx.globalAlpha = 1.0;
    }, []);
    
    const animate = useCallback(() => {
        if (!isRunning || !videoRef.current) return;
        
        const video = videoRef.current;
        if (video.readyState >= 2) {
            const inputCtx = inputCanvasRef.current?.getContext('2d');
            const temporalCtx = temporalCanvasRef.current?.getContext('2d');
            const semanticCtx = semanticCanvasRef.current?.getContext('2d');
            
            if (inputCtx && temporalCtx && semanticCtx) {
                // Capture frame
                inputCtx.drawImage(video, 0, 0, FIELD_SIZE, FIELD_SIZE);
                const imageData = inputCtx.getImageData(0, 0, FIELD_SIZE, FIELD_SIZE);
                
                // Process through temporal field
                temporalFieldRef.current.updateFromImage(imageData);
                
                // Render all views
                renderInput(inputCtx, imageData);
                renderTemporalField(temporalCtx);
                renderSemanticSpace(semanticCtx);
                
                // Update stats
                const temporalField = temporalFieldRef.current;
                setStats({
                    concepts: temporalField.concepts.size,
                    activeScouts: temporalField.scouts.filter(s => s.energy > 0.1).length,
                    semanticDepth: Array.from(temporalField.concepts.values())
                        .reduce((sum, c) => sum + c.stability, 0)
                });
            }
        }
        
        animationRef.current = requestAnimationFrame(animate);
    }, [isRunning, renderInput, renderTemporalField, renderSemanticSpace]);
    
    useEffect(() => {
        if (isRunning) {
            animate();
        } else if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
        }
        
        return () => {
            if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
            }
        };
    }, [isRunning, animate]);
    
    const resetSystem = () => {
        temporalFieldRef.current = new TemporalField();
        setStats({ concepts: 0, activeScouts: 0, semanticDepth: 0 });
    };
    
    const exportConcepts = () => {
        const concepts = Array.from(temporalFieldRef.current.concepts.values());
        const exportData = {
            timestamp: Date.now(),
            concepts: concepts.map(c => ({
                name: c.name,
                position: [c.centerX, c.centerY],
                stability: c.stability,
                coherence: c.coherence,
                age: c.age,
                signature: Array.from(c.signature)
            }))
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `concepts_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
    };
    
    return (
        <div className="w-full h-screen bg-black text-white flex flex-col">
            <video ref={videoRef} className="hidden" playsInline muted />
            
            {/* Header */}
            <div className="p-4 bg-gray-900 border-b border-gray-700">
                <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                        <Brain className="text-cyan-400" size={24} />
                        <h1 className="text-xl font-bold">Temporal Semantic Emergence</h1>
                    </div>
                    
                    <div className="flex items-center gap-4">
                        <div className="text-sm space-x-4">
                            <span>Concepts: <span className="text-yellow-400">{stats.concepts}</span></span>
                            <span>Active Scouts: <span className="text-cyan-400">{stats.activeScouts}</span></span>
                            <span>Semantic Depth: <span className="text-green-400">{stats.semanticDepth.toFixed(2)}</span></span>
                        </div>
                        
                        <div className="flex gap-2">
                            {!isRunning ? (
                                <button 
                                    onClick={startCamera}
                                    className="flex items-center gap-2 px-4 py-2 bg-green-600 hover:bg-green-700 rounded transition-colors"
                                >
                                    <Video size={16} /> Start Camera
                                </button>
                            ) : (
                                <button 
                                    onClick={() => setIsRunning(false)}
                                    className="flex items-center gap-2 px-4 py-2 bg-red-600 hover:bg-red-700 rounded transition-colors"
                                >
                                    <Pause size={16} /> Stop
                                </button>
                            )}
                            
                            <button 
                                onClick={resetSystem}
                                className="flex items-center gap-2 px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded transition-colors"
                            >
                                <RotateCcw size={16} /> Reset
                            </button>
                            
                            <button 
                                onClick={exportConcepts}
                                className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded transition-colors"
                            >
                                <Download size={16} /> Export
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            {/* Main Display */}
            <div className="flex-1 grid grid-cols-3 gap-2 p-2">
                {/* Reality Stream */}
                <div className="bg-gray-900 border border-gray-700 rounded flex flex-col">
                    <div className="p-2 border-b border-gray-700">
                        <h3 className="text-cyan-400 font-semibold">🎥 Reality Stream</h3>
                    </div>
                    <div className="flex-1 flex items-center justify-center">
                        <canvas 
                            ref={inputCanvasRef}
                            width={FIELD_SIZE}
                            height={FIELD_SIZE}
                            className="max-w-full max-h-full border border-gray-600"
                        />
                    </div>
                </div>
                
                {/* Temporal Emergence Field */}
                <div className="bg-gray-900 border border-gray-700 rounded flex flex-col">
                    <div className="p-2 border-b border-gray-700">
                        <h3 className="text-orange-400 font-semibold">⚡ Temporal Emergence Field</h3>
                    </div>
                    <div className="flex-1 flex items-center justify-center">
                        <canvas 
                            ref={temporalCanvasRef}
                            width={FIELD_SIZE}
                            height={FIELD_SIZE}
                            className="max-w-full max-h-full border border-gray-600"
                        />
                    </div>
                </div>
                
                {/* Concept Crystallization */}
                <div className="bg-gray-900 border border-gray-700 rounded flex flex-col">
                    <div className="p-2 border-b border-gray-700">
                        <h3 className="text-purple-400 font-semibold">🧠 Concept Crystallization</h3>
                    </div>
                    <div className="flex-1 flex items-center justify-center">
                        <canvas 
                            ref={semanticCanvasRef}
                            width={FIELD_SIZE}
                            height={FIELD_SIZE}
                            className="max-w-full max-h-full border border-gray-600"
                        />
                    </div>
                </div>
            </div>
            
            {/* Status Footer */}
            <div className="p-2 bg-gray-800 border-t border-gray-700 text-xs text-gray-400">
                {isRunning ? 
                    "🟢 System active - Discovering temporal patterns and emerging concepts..." : 
                    "🔴 System inactive - Click 'Start Camera' to begin temporal semantic emergence"
                }
            </div>
        </div>
    );
};

export default TemporalSemanticEmergence;